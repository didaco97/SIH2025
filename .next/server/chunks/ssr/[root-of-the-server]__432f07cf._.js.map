{"version":3,"sources":["../../../../src/lib/firebase.ts","../../../../src/contexts/AuthContext.tsx","../../../../src/lib/blockchain.ts","../../../../src/lib/firestore.ts"],"sourcesContent":["import { initializeApp, getApps, getApp, FirebaseApp } from 'firebase/app';\r\nimport { getAuth, Auth } from 'firebase/auth';\r\nimport { getFirestore, Firestore } from 'firebase/firestore';\r\nimport { getStorage, FirebaseStorage } from 'firebase/storage';\r\n\r\nconst firebaseConfig = {\r\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\r\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\r\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\r\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\r\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\r\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\r\n};\r\n\r\n// Check if Firebase config is properly set\r\nconst isConfigured = firebaseConfig.apiKey &&\r\n    firebaseConfig.apiKey !== 'your_api_key_here' &&\r\n    firebaseConfig.projectId;\r\n\r\n// Initialize Firebase (prevent re-initialization in development)\r\nlet app: FirebaseApp | null = null;\r\nlet auth: Auth | null = null;\r\nlet db: Firestore | null = null;\r\nlet storage: FirebaseStorage | null = null;\r\n\r\nif (isConfigured) {\r\n    try {\r\n        app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();\r\n        auth = getAuth(app);\r\n        db = getFirestore(app, \"krishisense\"); // Using named database 'krishisense'\r\n        storage = getStorage(app);\r\n    } catch (error) {\r\n        console.error('Firebase initialization error:', error);\r\n    }\r\n} else {\r\n    console.warn(\r\n        '⚠️ Firebase is not configured. Please set up your .env.local file with Firebase credentials.\\n' +\r\n        'Copy .env.example to .env.local and fill in your Firebase config values.\\n' +\r\n        'Get these from: Firebase Console > Project Settings > Your Apps > Web App'\r\n    );\r\n}\r\n\r\n// Export a flag to check if Firebase is ready\r\nexport const isFirebaseConfigured = isConfigured && app !== null;\r\n\r\n// Firebase services (may be null if not configured)\r\nexport { auth, db, storage };\r\n\r\nexport default app;\r\n","\"use client\";\r\n\r\nimport React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\r\nimport {\r\n    User,\r\n    onAuthStateChanged,\r\n    signInWithEmailAndPassword,\r\n    createUserWithEmailAndPassword,\r\n    signOut as firebaseSignOut,\r\n    GoogleAuthProvider,\r\n    signInWithPopup,\r\n    sendPasswordResetEmail,\r\n    updateProfile,\r\n    Auth,\r\n} from 'firebase/auth';\r\nimport { doc, getDoc, setDoc, serverTimestamp, Firestore } from 'firebase/firestore';\r\nimport { auth, db, isFirebaseConfigured } from '@/lib/firebase';\r\n\r\nexport type UserRole = 'farmer' | 'officer';\r\n\r\nexport interface UserProfile {\r\n    uid: string;\r\n    email: string | null;\r\n    displayName: string | null;\r\n    role: UserRole;\r\n    district?: string;\r\n    village?: string;\r\n    phone?: string;\r\n    createdAt?: Date;\r\n}\r\n\r\ninterface AuthContextType {\r\n    user: User | null;\r\n    userProfile: UserProfile | null;\r\n    loading: boolean;\r\n    error: string | null;\r\n    isConfigured: boolean;\r\n    signIn: (email: string, password: string) => Promise<void>;\r\n    signUp: (email: string, password: string, name: string, role: UserRole) => Promise<void>;\r\n    signInWithGoogle: (role?: UserRole) => Promise<void>;\r\n    signOut: () => Promise<void>;\r\n    resetPassword: (email: string) => Promise<void>;\r\n    clearError: () => void;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nconst googleProvider = new GoogleAuthProvider();\r\n\r\n// Helper to check auth is available\r\nfunction getAuth(): Auth {\r\n    if (!auth) {\r\n        throw new Error('Firebase Auth is not configured. Please set up your .env.local file.');\r\n    }\r\n    return auth;\r\n}\r\n\r\n// Helper to check db is available\r\nfunction getDb(): Firestore {\r\n    if (!db) {\r\n        throw new Error('Firebase Firestore is not configured. Please set up your .env.local file.');\r\n    }\r\n    return db;\r\n}\r\n\r\nexport function AuthProvider({ children }: { children: ReactNode }) {\r\n    const [user, setUser] = useState<User | null>(null);\r\n    const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    // Fetch user profile from Firestore\r\n    const fetchUserProfile = async (uid: string): Promise<UserProfile | null> => {\r\n        try {\r\n            const userDoc = await getDoc(doc(getDb(), 'users', uid));\r\n            if (userDoc.exists()) {\r\n                const data = userDoc.data();\r\n                return {\r\n                    uid,\r\n                    email: data.email,\r\n                    displayName: data.displayName,\r\n                    role: data.role,\r\n                    district: data.district,\r\n                    village: data.village,\r\n                    phone: data.phone,\r\n                    createdAt: data.createdAt?.toDate(),\r\n                };\r\n            }\r\n            return null;\r\n        } catch (err) {\r\n            console.error('Error fetching user profile:', err);\r\n            return null;\r\n        }\r\n    };\r\n\r\n    // Create user profile in Firestore\r\n    const createUserProfile = async (\r\n        uid: string,\r\n        email: string,\r\n        displayName: string,\r\n        role: UserRole\r\n    ) => {\r\n        await setDoc(doc(getDb(), 'users', uid), {\r\n            email,\r\n            displayName,\r\n            role,\r\n            createdAt: serverTimestamp(),\r\n        });\r\n    };\r\n\r\n    // Listen to auth state changes\r\n    useEffect(() => {\r\n        // If Firebase is not configured, just mark as not loading\r\n        if (!isFirebaseConfigured || !auth) {\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {\r\n            setUser(firebaseUser);\r\n\r\n            if (firebaseUser) {\r\n                const profile = await fetchUserProfile(firebaseUser.uid);\r\n                setUserProfile(profile);\r\n            } else {\r\n                setUserProfile(null);\r\n            }\r\n\r\n            setLoading(false);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, []);\r\n\r\n    // Sign in with email/password\r\n    const signIn = async (email: string, password: string) => {\r\n        try {\r\n            setError(null);\r\n            setLoading(true);\r\n            await signInWithEmailAndPassword(getAuth(), email, password);\r\n        } catch (err: any) {\r\n            setError(err.message || 'Failed to sign in');\r\n            throw err;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    // Sign up with email/password\r\n    const signUp = async (email: string, password: string, name: string, role: UserRole) => {\r\n        try {\r\n            setError(null);\r\n            setLoading(true);\r\n\r\n            const result = await createUserWithEmailAndPassword(getAuth(), email, password);\r\n\r\n            // Update display name\r\n            await updateProfile(result.user, { displayName: name });\r\n\r\n            // Create user profile in Firestore\r\n            await createUserProfile(result.user.uid, email, name, role);\r\n\r\n            // Fetch the profile\r\n            const profile = await fetchUserProfile(result.user.uid);\r\n            setUserProfile(profile);\r\n        } catch (err: any) {\r\n            setError(err.message || 'Failed to create account');\r\n            throw err;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    // Sign in with Google\r\n    const signInWithGoogle = async (role: UserRole = 'farmer') => {\r\n        try {\r\n            setError(null);\r\n            setLoading(true);\r\n\r\n            const result = await signInWithPopup(getAuth(), googleProvider);\r\n\r\n            // Check if user profile exists\r\n            const existingProfile = await fetchUserProfile(result.user.uid);\r\n\r\n            if (!existingProfile) {\r\n                // Create new profile for first-time Google users\r\n                await createUserProfile(\r\n                    result.user.uid,\r\n                    result.user.email || '',\r\n                    result.user.displayName || '',\r\n                    role\r\n                );\r\n            }\r\n\r\n            const profile = await fetchUserProfile(result.user.uid);\r\n            setUserProfile(profile);\r\n        } catch (err: any) {\r\n            setError(err.message || 'Failed to sign in with Google');\r\n            throw err;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    // Sign out\r\n    const signOut = async () => {\r\n        try {\r\n            await firebaseSignOut(getAuth());\r\n            setUserProfile(null);\r\n        } catch (err: any) {\r\n            setError(err.message || 'Failed to sign out');\r\n            throw err;\r\n        }\r\n    };\r\n\r\n    // Reset password\r\n    const resetPassword = async (email: string) => {\r\n        try {\r\n            setError(null);\r\n            await sendPasswordResetEmail(getAuth(), email);\r\n        } catch (err: any) {\r\n            setError(err.message || 'Failed to send password reset email');\r\n            throw err;\r\n        }\r\n    };\r\n\r\n    // Clear error\r\n    const clearError = () => setError(null);\r\n\r\n    const value: AuthContextType = {\r\n        user,\r\n        userProfile,\r\n        loading,\r\n        error,\r\n        isConfigured: !!isFirebaseConfigured,\r\n        signIn,\r\n        signUp,\r\n        signInWithGoogle,\r\n        signOut,\r\n        resetPassword,\r\n        clearError,\r\n    };\r\n\r\n    return (\r\n        <AuthContext.Provider value={value}>\r\n            {children}\r\n        </AuthContext.Provider>\r\n    );\r\n}\r\n\r\nexport function useAuth() {\r\n    const context = useContext(AuthContext);\r\n    if (context === undefined) {\r\n        throw new Error('useAuth must be used within an AuthProvider');\r\n    }\r\n    return context;\r\n}\r\n","\r\n/**\r\n * Generates a SHA-256 hash for the given data string.\r\n * This simulates storing a record on a blockchain by creating a verifiable cryptographic hash\r\n * of the report content or URL.\r\n */\r\nexport async function generateBlockchainHash(data: string): Promise<string> {\r\n    // Encodes the data string into a Uint8Array\r\n    const encoder = new TextEncoder();\r\n    const dataBuffer = encoder.encode(data);\r\n\r\n    // Computes the SHA-256 hash\r\n    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\r\n\r\n    // Convert the buffer to a hex string\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n\r\n    return hashHex;\r\n}\r\n","import {\r\n    collection,\r\n    doc,\r\n    getDoc,\r\n    getDocs,\r\n    setDoc,\r\n    updateDoc,\r\n    deleteDoc,\r\n    query,\r\n    where,\r\n    limit,\r\n    QueryConstraint,\r\n    orderBy,\r\n    serverTimestamp,\r\n    Timestamp,\r\n    addDoc,\r\n    onSnapshot,\r\n    Unsubscribe,\r\n    Firestore,\r\n} from 'firebase/firestore';\r\nimport { db, isFirebaseConfigured } from './firebase';\r\nimport { generateBlockchainHash } from './blockchain';\r\n\r\n// Helper to ensure Firestore is configured\r\nfunction getDb(): Firestore {\r\n    if (!db) {\r\n        throw new Error(\r\n            'Firebase is not configured. Please set up your .env.local file with Firebase credentials. ' +\r\n            'Copy .env.example to .env.local and add your Firebase config.'\r\n        );\r\n    }\r\n    return db;\r\n}\r\n\r\n// ==================== USER FUNCTIONS ====================\r\n\r\nexport interface UserData {\r\n    uid: string;\r\n    email: string;\r\n    displayName: string;\r\n    role: 'farmer' | 'officer';\r\n    district?: string;\r\n    village?: string;\r\n    phone?: string;\r\n    createdAt: Timestamp;\r\n}\r\n\r\nexport async function getUserProfile(userId: string): Promise<UserData | null> {\r\n    const userDoc = await getDoc(doc(getDb(), 'users', userId));\r\n    if (userDoc.exists()) {\r\n        return { uid: userId, ...userDoc.data() } as UserData;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function updateUserProfile(\r\n    userId: string,\r\n    data: Partial<Omit<UserData, 'uid' | 'createdAt'>>\r\n): Promise<void> {\r\n    await updateDoc(doc(getDb(), 'users', userId), {\r\n        ...data,\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n}\r\n\r\n// ==================== FARM FUNCTIONS ====================\r\n\r\nexport interface FarmData {\r\n    id?: string;\r\n    userId: string;\r\n    name: string;\r\n    landArea: number;\r\n    landAreaUnit: 'acres' | 'hectares';\r\n    cropType: string;\r\n    sowingDate: Timestamp;\r\n    location: {\r\n        lat: number;\r\n        lng: number;\r\n    };\r\n    boundary?: {\r\n        type: 'Polygon';\r\n        coordinates: number[][][];\r\n    };\r\n    district: string;\r\n    taluka?: string;\r\n    village?: string;\r\n    surveyNumber?: string;\r\n    createdAt?: Timestamp;\r\n}\r\n\r\nexport async function createFarm(data: Omit<FarmData, 'id' | 'createdAt'>): Promise<string> {\r\n    const farmRef = await addDoc(collection(getDb(), 'farms'), {\r\n        ...data,\r\n        createdAt: serverTimestamp(),\r\n    });\r\n    return farmRef.id;\r\n}\r\n\r\nexport async function getFarm(farmId: string): Promise<FarmData | null> {\r\n    const farmDoc = await getDoc(doc(getDb(), 'farms', farmId));\r\n    if (farmDoc.exists()) {\r\n        return { id: farmId, ...farmDoc.data() } as FarmData;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function getUserFarms(userId: string): Promise<FarmData[]> {\r\n    const farmsQuery = query(\r\n        collection(getDb(), 'farms'),\r\n        where('userId', '==', userId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(farmsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as FarmData));\r\n}\r\n\r\nexport async function updateFarm(\r\n    farmId: string,\r\n    data: Partial<Omit<FarmData, 'id' | 'createdAt'>>\r\n): Promise<void> {\r\n    await updateDoc(doc(getDb(), 'farms', farmId), {\r\n        ...data,\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n}\r\n\r\nexport async function deleteFarm(farmId: string): Promise<void> {\r\n    await deleteDoc(doc(getDb(), 'farms', farmId));\r\n}\r\n\r\n// ==================== CLAIM FUNCTIONS ====================\r\n\r\nexport type ClaimStatus = 'pending' | 'waiting' | 'approved' | 'rejected';\r\nexport type LossType = 'drought' | 'flood' | 'pest' | 'fire' | 'landslide' | 'hailstorm' | 'other';\r\nexport type CropStage = 'sowing' | 'vegetative' | 'flowering' | 'maturity';\r\n\r\nexport interface ClaimData {\r\n    id?: string;\r\n    claimNumber?: string;        // Auto-generated: CLM-YYYY-XXX\r\n    farmerId: string;            // User who filed or farmer ID entered\r\n    farmerName: string;\r\n    userId: string;              // User who submitted (could be officer)\r\n    filedBy: 'farmer' | 'officer';\r\n\r\n    // Farm/Location Info\r\n    farmId?: string;\r\n    farmName?: string;\r\n    village: string;\r\n    district: string;\r\n    taluka?: string;\r\n    surveyNumber?: string;\r\n    latitude?: number;           // Farm coordinates\r\n    longitude?: number;\r\n\r\n    // Crop Info\r\n    cropType: string;\r\n    area: number;\r\n    areaUnit: 'acres' | 'hectares';\r\n    policyNumber?: string;\r\n\r\n    // Loss Details\r\n    lossType: LossType;\r\n    lossDate: Timestamp;\r\n    cropStage: CropStage;\r\n    harvestDate?: Timestamp;\r\n    description: string;\r\n\r\n    // Claim Amount\r\n    amount: number;\r\n    status: ClaimStatus;\r\n\r\n    // Documents\r\n    documents: string[];         // Storage URLs for proof images\r\n    document712Url?: string;     // 7/12 extract URL\r\n    reportId?: string;           // Reference to latest generated report\r\n    reportUrl?: string;          // PDF download URL\r\n    reportGeneratedAt?: Timestamp;\r\n\r\n    // Processing\r\n    officerNotes?: string;\r\n    processedBy?: string;\r\n    processedAt?: Timestamp;\r\n\r\n    // Blockchain Verification\r\n    blockchainHash?: string;          // SHA-256 hash of report\r\n    blockchainTxHash?: string;        // On-chain transaction hash\r\n    blockchainExplorerUrl?: string;   // Link to block explorer\r\n\r\n    createdAt?: Timestamp;\r\n    updatedAt?: Timestamp;\r\n}\r\n\r\n// Generate a unique claim number\r\nasync function generateClaimNumber(): Promise<string> {\r\n    const year = new Date().getFullYear();\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    const count = snapshot.size + 1;\r\n    return `CLM-${year}-${String(count).padStart(4, '0')}`;\r\n}\r\n\r\nexport async function createClaim(data: Omit<ClaimData, 'id' | 'claimNumber' | 'createdAt' | 'updatedAt'>): Promise<string> {\r\n    const claimNumber = await generateClaimNumber();\r\n    const claimRef = await addDoc(collection(getDb(), 'claims'), {\r\n        ...data,\r\n        claimNumber,\r\n        status: data.status || 'pending',\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n    return claimRef.id;\r\n}\r\n\r\nexport async function getClaim(claimId: string): Promise<ClaimData | null> {\r\n    const claimDoc = await getDoc(doc(getDb(), 'claims', claimId));\r\n    if (claimDoc.exists()) {\r\n        return { id: claimId, ...claimDoc.data() } as ClaimData;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function getUserClaims(userId: string): Promise<ClaimData[]> {\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        where('userId', '==', userId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n}\r\n\r\nexport async function getClaimsByFarmerId(farmerId: string): Promise<ClaimData[]> {\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        where('farmerId', '==', farmerId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n}\r\n\r\nexport async function getFarmClaims(farmId: string): Promise<ClaimData[]> {\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        where('farmId', '==', farmId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n}\r\n\r\nexport async function getClaimsByStatus(status: ClaimStatus): Promise<ClaimData[]> {\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        where('status', '==', status),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n}\r\n\r\nexport async function getAllClaims(): Promise<ClaimData[]> {\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(claimsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n}\r\n\r\nexport async function updateClaimStatus(\r\n    claimId: string,\r\n    status: ClaimStatus,\r\n    officerNotes?: string,\r\n    processedBy?: string\r\n): Promise<void> {\r\n    await updateDoc(doc(getDb(), 'claims', claimId), {\r\n        status,\r\n        officerNotes,\r\n        processedBy,\r\n        processedAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n}\r\n\r\nexport async function updateClaimBlockchainInfo(\r\n    claimId: string,\r\n    txHash: string,\r\n    explorerUrl: string\r\n): Promise<void> {\r\n    await updateDoc(doc(getDb(), 'claims', claimId), {\r\n        blockchainTxHash: txHash,\r\n        blockchainExplorerUrl: explorerUrl,\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n}\r\n\r\nexport async function updateClaim(\r\n    claimId: string,\r\n    data: Partial<Omit<ClaimData, 'id' | 'createdAt'>>\r\n): Promise<void> {\r\n    await updateDoc(doc(getDb(), 'claims', claimId), {\r\n        ...data,\r\n        updatedAt: serverTimestamp(),\r\n    });\r\n}\r\n\r\n// ==================== DOCUMENT FUNCTIONS ====================\r\n\r\nexport interface DocumentData {\r\n    id?: string;\r\n    userId: string;\r\n    farmId?: string;\r\n    claimId?: string;\r\n    type: '712' | 'land_record' | 'photo' | 'other';\r\n    name: string;\r\n    url: string;\r\n    extractedData?: Record<string, any>;\r\n    createdAt?: Timestamp;\r\n}\r\n\r\nexport async function saveDocument(data: Omit<DocumentData, 'id' | 'createdAt'>): Promise<string> {\r\n    const docRef = await addDoc(collection(getDb(), 'documents'), {\r\n        ...data,\r\n        createdAt: serverTimestamp(),\r\n    });\r\n    return docRef.id;\r\n}\r\n\r\nexport async function getUserDocuments(userId: string): Promise<DocumentData[]> {\r\n    const docsQuery = query(\r\n        collection(getDb(), 'documents'),\r\n        where('userId', '==', userId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(docsQuery);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as DocumentData));\r\n}\r\n\r\n// ==================== SEGMENTED FARM FUNCTIONS ====================\r\n\r\nexport interface GeoJsonFeature {\r\n    type: string;\r\n    properties: {\r\n        area_m2?: number;\r\n    };\r\n    geometry: {\r\n        type: string;\r\n        coordinates: number[][][];\r\n    };\r\n}\r\n\r\nexport interface SegmentedFarmData {\r\n    id?: string;\r\n    claimId: string;              // Reference to the claim\r\n    farmerId: string;\r\n    farmerName: string;\r\n    village: string;\r\n    district?: string;\r\n    surveyNo?: string;\r\n    cropType?: string;\r\n    color: string;\r\n    features: GeoJsonFeature[];   // Polygon coordinates\r\n    areaM2: number;\r\n    createdAt?: Timestamp;\r\n    createdBy: string;            // Officer who segmented\r\n}\r\n\r\nexport async function saveSegmentedFarm(data: Omit<SegmentedFarmData, 'id' | 'createdAt'>): Promise<string> {\r\n    // Firestore doesn't support nested arrays, so serialize features to JSON string\r\n    const dataToSave = {\r\n        ...data,\r\n        featuresJson: JSON.stringify(data.features), // Store as JSON string\r\n        features: undefined, // Don't save the original nested array\r\n        createdAt: serverTimestamp(),\r\n    };\r\n    delete dataToSave.features;\r\n\r\n    const docRef = await addDoc(collection(getDb(), 'segmentedFarms'), dataToSave);\r\n    return docRef.id;\r\n}\r\n\r\nexport async function getSegmentedFarms(): Promise<SegmentedFarmData[]> {\r\n    const q = query(\r\n        collection(getDb(), 'segmentedFarms'),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map((doc) => {\r\n        const data = doc.data();\r\n        // Parse featuresJson back to features array\r\n        const features = data.featuresJson ? JSON.parse(data.featuresJson) : [];\r\n        return { id: doc.id, ...data, features } as SegmentedFarmData;\r\n    });\r\n}\r\n\r\nexport async function getSegmentedFarmById(farmId: string): Promise<SegmentedFarmData | null> {\r\n    const farmDoc = await getDoc(doc(getDb(), 'segmentedFarms', farmId));\r\n    if (farmDoc.exists()) {\r\n        const data = farmDoc.data();\r\n        const features = data.featuresJson ? JSON.parse(data.featuresJson) : [];\r\n        return { id: farmId, ...data, features } as SegmentedFarmData;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function getSegmentedFarmsByClaimId(claimId: string): Promise<SegmentedFarmData[]> {\r\n    const q = query(\r\n        collection(getDb(), 'segmentedFarms'),\r\n        where('claimId', '==', claimId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map((doc) => {\r\n        const data = doc.data();\r\n        const features = data.featuresJson ? JSON.parse(data.featuresJson) : [];\r\n        return { id: doc.id, ...data, features } as SegmentedFarmData;\r\n    });\r\n}\r\n\r\nexport async function deleteSegmentedFarm(farmId: string): Promise<void> {\r\n    await deleteDoc(doc(getDb(), 'segmentedFarms', farmId));\r\n}\r\n\r\n// ==================== REPORT FUNCTIONS ====================\r\n\r\nexport interface ReportData {\r\n    id?: string;\r\n    claimId: string;\r\n    farmId?: string;\r\n    farmerId?: string;\r\n    farmerName?: string;\r\n    reportType: 'yield_prediction';\r\n\r\n    // Report content summary\r\n    predictedYield?: number;\r\n    threshold?: number;\r\n    claimTriggered?: boolean;\r\n    lossPercentage?: number;\r\n    healthStatus?: string;\r\n\r\n    // Verification\r\n    verifiedBy: string;\r\n    verifiedAt: Timestamp;\r\n\r\n    // PDF Storage\r\n    pdfUrl: string;\r\n    fileName: string;\r\n\r\n    // Metadata\r\n    createdAt?: Timestamp;\r\n}\r\n\r\nexport async function saveReport(data: Omit<ReportData, 'id' | 'createdAt'>): Promise<{ reportId: string; blockchainHash?: string }> {\r\n    const reportRef = await addDoc(collection(getDb(), 'reports'), {\r\n        ...data,\r\n        createdAt: serverTimestamp(),\r\n    });\r\n\r\n    let blockHash: string | undefined;\r\n\r\n    // Also update the claim with the report reference and set status to 'waiting' (Under Review)\r\n    if (data.claimId) {\r\n        // Generate blockchain hash from the report URL + Timestamp for uniqueness/integrity\r\n        const hashInput = `${data.pdfUrl}-${Date.now()}`;\r\n        blockHash = await generateBlockchainHash(hashInput);\r\n\r\n        await updateDoc(doc(getDb(), 'claims', data.claimId), {\r\n            reportId: reportRef.id,\r\n            reportUrl: data.pdfUrl,\r\n            status: 'waiting',\r\n            reportGeneratedAt: serverTimestamp(),\r\n            blockchainHash: blockHash,\r\n            updatedAt: serverTimestamp(),\r\n        });\r\n    }\r\n\r\n    return { reportId: reportRef.id, blockchainHash: blockHash };\r\n}\r\n\r\nexport async function getClaimReports(claimId: string): Promise<ReportData[]> {\r\n    const q = query(\r\n        collection(getDb(), 'reports'),\r\n        where('claimId', '==', claimId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ReportData));\r\n}\r\n\r\nexport async function getReport(reportId: string): Promise<ReportData | null> {\r\n    const reportDoc = await getDoc(doc(getDb(), 'reports', reportId));\r\n    if (reportDoc.exists()) {\r\n        return { id: reportId, ...reportDoc.data() } as ReportData;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function subscribeToClaimsByStatus(\r\n    status: ClaimStatus,\r\n    callback: (claims: ClaimData[]) => void,\r\n    limitCount?: number\r\n): Unsubscribe {\r\n    const constraints: QueryConstraint[] = [\r\n        where('status', '==', status)\r\n    ];\r\n\r\n    // NOTE: Removed server-side orderBy/limit to avoid \"Index Required\" errors during development.\r\n    // Fetching all (filtered by status) and sorting/limiting client-side.\r\n    // For production with >1000 claims, revert this and create Firestore Indexes.\r\n\r\n    const claimsQuery = query(\r\n        collection(getDb(), 'claims'),\r\n        ...constraints\r\n    );\r\n\r\n    return onSnapshot(claimsQuery, (snapshot) => {\r\n        let claims = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ClaimData));\r\n\r\n        // Sort client-side (Newest first)\r\n        claims.sort((a, b) => {\r\n            const timeA = a.createdAt?.toMillis() || 0;\r\n            const timeB = b.createdAt?.toMillis() || 0;\r\n            return timeB - timeA;\r\n        });\r\n\r\n        // Limit client-side\r\n        if (limitCount && limitCount > 0) {\r\n            claims = claims.slice(0, limitCount);\r\n        }\r\n\r\n        callback(claims);\r\n    });\r\n}\r\n"],"names":[],"mappings":"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"}